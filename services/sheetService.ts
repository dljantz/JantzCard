
import { Card } from '../types';

export class RowNotFoundError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "RowNotFoundError";
  }
}

export interface PendingCardUpdate {
  id: string;
  lastSeen: string | null;
  currentStudyInterval: string | null;
}

/**
 * Extracts the Spreadsheet ID from a standard Google Sheets URL.
 */
export const extractSpreadsheetId = (url: string): string | null => {
  const matches = url.match(/\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
  return matches ? matches[1] : null;
};

/**
 * Fetches the title of the spreadsheet.
 */
export const getSpreadsheetTitle = async (spreadsheetId: string): Promise<string> => {
  if (!window.gapi?.client?.sheets) {
    return "Unknown Deck";
  }
  try {
    const response = await window.gapi.client.sheets.spreadsheets.get({
      spreadsheetId,
      fields: 'properties.title'
    });
    return response.result.properties?.title || "Untitled Deck";
  } catch (e) {
    console.error("Failed to fetch sheet title", e);
    return "Study Deck";
  }
};

/**
 * Generates a unique ID for cards that don't have one.
 */
const generateUniqueId = (): string => {
  if (typeof crypto !== 'undefined' && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  // Fallback for older environments
  return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
};

/**
 * Loads cards from the user's spreadsheet.
 * Schema:
 * A: Front
 * B: Back
 * C: Category
 * D: Priority
 * E: Last Seen
 * F: Interval
 * F: Interval
 * G: Status
 * H: ID (Generated by App)
 */
export const loadCardsFromSheet = async (spreadsheetId: string): Promise<Card[]> => {
  if (!window.gapi?.client?.sheets) {
    throw new Error("Google Sheets API not loaded");
  }

  const response = await window.gapi.client.sheets.spreadsheets.values.get({
    spreadsheetId,
    range: 'Deck!A2:H', // Fetch columns A through H, starting at row 2
  });

  const rows = response.result.values;
  if (!rows || rows.length === 0) {
    return [];
  }

  return rows.map((row: any[], index: number) => {
    let id = row[7]; // Column H
    const status = row[6]; // Column G

    // If ID is missing, generate one in memory. 
    // It will be saved to the sheet on the next user interaction with this card.
    if (!id) {
      id = generateUniqueId();
    }

    // Logic for Priority:
    // Defaults to Number.MAX_SAFE_INTEGER (lowest possible priority) if empty or invalid.
    const parsedPriority = parseInt(row[3]);
    const priorityLevel = isNaN(parsedPriority) ? Number.MAX_SAFE_INTEGER : parsedPriority;

    return {
      id: id,
      front: row[0] || '',
      back: row[1] || '',
      category: row[2] || 'General',
      priorityLevel: priorityLevel,
      lastSeen: row[4] || null,
      currentStudyInterval: row[5] || null,
      status: status || 'Active',
    };
  }).filter((c: Card) => !!c.front && c.status !== 'Inactive'); // Only load cards where Front is present and Status is not Inactive
};

/**
 * Helper to find the row index for a specific card.
 * Strategy:
 * 1. Look for ID match in Column G.
 * 2. Fallback: Look for Front+Back match in Columns A & B.
 */
const findRowForCard = async (spreadsheetId: string, card: Card): Promise<number | null> => {
  // 1. Fetch IDs (Col G) and Front/Back (Cols A-B)
  // We fetch A:G to be safe and reduce API calls, though strictly we just need A,B,G.
  const response = await window.gapi.client.sheets.spreadsheets.values.get({
    spreadsheetId,
    range: 'Deck!A2:H',
    majorDimension: 'ROWS'
  });

  const rows = response.result.values;
  if (!rows) return null;

  // Search by ID first (Robust against reordering)
  let foundIndex = rows.findIndex((row: any[]) => row[7] === card.id);

  // Fallback: Search by Content (For first-time saves where ID isn't in sheet yet)
  if (foundIndex === -1) {
    foundIndex = rows.findIndex((row: any[]) => row[0] === card.front && row[1] === card.back);
  }

  if (foundIndex !== -1) {
    // Return actual spreadsheet row number (Index + 2 because data starts at A2)
    return foundIndex + 2;
  }

  return null;
};

/**
 * Updates Last Seen, Interval, and ID for a specific card.
 * Finds the correct row dynamically to handle spreadsheet sorting.
 */
export const updateCardInSheet = async (spreadsheetId: string, card: Card): Promise<void> => {
  if (!window.gapi?.client?.sheets) {
    throw new Error("Google Sheets API not loaded");
  }

  const rowNumber = await findRowForCard(spreadsheetId, card);

  if (!rowNumber) {
    throw new RowNotFoundError(`Could not find row for card ID: ${card.id}. Has the card been deleted from the sheet?`);
  }

  // Update Columns E (Last Seen), F (Interval), G (Status), and H (ID)
  // Writing ID ensures that if it was a generated ID, it is now persisted.
  const range = `Deck!E${rowNumber}:H${rowNumber}`;

  const values = [
    [
      card.lastSeen,
      card.currentStudyInterval,
      card.status || 'Active',
      card.id
    ]
  ];

  await window.gapi.client.sheets.spreadsheets.values.update({
    spreadsheetId,
    range,
    valueInputOption: 'RAW',
    resource: {
      values
    }
  });
};

/**
 * Performs a batch update for multiple cards.
 * Used for syncing the offline backlog.
 */
export const batchUpdateCards = async (spreadsheetId: string, updates: PendingCardUpdate[]): Promise<void> => {
  if (!window.gapi?.client?.sheets) {
    throw new Error("Google Sheets API not loaded");
  }

  // 1. Fetch current sheet state to map IDs to Rows
  const response = await window.gapi.client.sheets.spreadsheets.values.get({
    spreadsheetId,
    range: 'Deck!A2:H',
  });
  const rows = response.result.values || [];

  const data: any[] = [];

  // 2. Build update payload
  for (const update of updates) {
    // Attempt ID match
    let rowIndex = rows.findIndex((row: any[]) => row[7] === update.id);

    if (rowIndex !== -1) {
      const rowNumber = rowIndex + 2;
      // Update E:F (Last Seen, Interval)
      data.push({
        range: `Deck!E${rowNumber}:F${rowNumber}`,
        values: [[update.lastSeen, update.currentStudyInterval]]
      });
      // Update H (ID)
      data.push({
        range: `Deck!H${rowNumber}`,
        values: [[update.id]]
      });
    }
  }

  if (data.length === 0) return;

  await window.gapi.client.sheets.spreadsheets.values.batchUpdate({
    spreadsheetId,
    resource: {
      valueInputOption: 'RAW',
      data: data
    }
  });
};
