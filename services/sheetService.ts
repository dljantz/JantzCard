
import { Card } from '../types';

export interface PendingCardUpdate {
  id: string;
  lastSeen: string | null;
  currentStudyInterval: string | null;
}

/**
 * Extracts the Spreadsheet ID from a standard Google Sheets URL.
 */
export const extractSpreadsheetId = (url: string): string | null => {
  const matches = url.match(/\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
  return matches ? matches[1] : null;
};

/**
 * Generates a unique ID for cards that don't have one.
 */
const generateUniqueId = (): string => {
  if (typeof crypto !== 'undefined' && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  // Fallback for older environments
  return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
};

/**
 * Loads cards from the user's spreadsheet.
 * Schema:
 * A: Front
 * B: Back
 * C: Category
 * D: Priority
 * E: Last Seen
 * F: Interval
 * G: ID (Generated by App)
 */
export const loadCardsFromSheet = async (spreadsheetId: string): Promise<Card[]> => {
  if (!window.gapi?.client?.sheets) {
    throw new Error("Google Sheets API not loaded");
  }

  const response = await window.gapi.client.sheets.spreadsheets.values.get({
    spreadsheetId,
    range: 'Sheet1!A2:G', // Fetch columns A through G, starting at row 2
  });

  const rows = response.result.values;
  if (!rows || rows.length === 0) {
    return [];
  }

  return rows.map((row: any[], index: number) => {
    let id = row[6]; // Column G

    // If ID is missing, generate one in memory. 
    // It will be saved to the sheet on the next user interaction with this card.
    if (!id) {
        id = generateUniqueId();
    }

    // Logic for Priority:
    // Defaults to Number.MAX_SAFE_INTEGER (lowest possible priority) if empty or invalid.
    const parsedPriority = parseInt(row[3]);
    const priorityLevel = isNaN(parsedPriority) ? Number.MAX_SAFE_INTEGER : parsedPriority;

    return {
      id: id,
      front: row[0] || '',
      back: row[1] || '',
      category: row[2] || 'General',
      priorityLevel: priorityLevel,
      lastSeen: row[4] || null,
      currentStudyInterval: row[5] || null,
    };
  }).filter((c: Card) => !!c.front); // Only load cards where Front is present (non-empty)
};

/**
 * Helper to find the row index for a specific card.
 * Strategy:
 * 1. Look for ID match in Column G.
 * 2. Fallback: Look for Front+Back match in Columns A & B.
 */
const findRowForCard = async (spreadsheetId: string, card: Card): Promise<number | null> => {
  // 1. Fetch IDs (Col G) and Front/Back (Cols A-B)
  // We fetch A:G to be safe and reduce API calls, though strictly we just need A,B,G.
  const response = await window.gapi.client.sheets.spreadsheets.values.get({
    spreadsheetId,
    range: 'Sheet1!A2:G', 
    majorDimension: 'ROWS'
  });

  const rows = response.result.values;
  if (!rows) return null;

  // Search by ID first (Robust against reordering)
  let foundIndex = rows.findIndex((row: any[]) => row[6] === card.id);

  // Fallback: Search by Content (For first-time saves where ID isn't in sheet yet)
  if (foundIndex === -1) {
    foundIndex = rows.findIndex((row: any[]) => row[0] === card.front && row[1] === card.back);
  }

  if (foundIndex !== -1) {
    // Return actual spreadsheet row number (Index + 2 because data starts at A2)
    return foundIndex + 2;
  }

  return null;
};

/**
 * Updates Last Seen, Interval, and ID for a specific card.
 * Finds the correct row dynamically to handle spreadsheet sorting.
 */
export const updateCardInSheet = async (spreadsheetId: string, card: Card): Promise<void> => {
  if (!window.gapi?.client?.sheets) {
    throw new Error("Google Sheets API not loaded");
  }

  const rowNumber = await findRowForCard(spreadsheetId, card);

  if (!rowNumber) {
    throw new Error(`Could not find row for card ID: ${card.id}. Has the card been deleted from the sheet?`);
  }
  
  // Update Columns E (Last Seen), F (Interval), and G (ID)
  // Writing ID ensures that if it was a generated ID, it is now persisted.
  const range = `Sheet1!E${rowNumber}:G${rowNumber}`;
  
  const values = [
    [
      card.lastSeen,
      card.currentStudyInterval,
      card.id
    ]
  ];

  await window.gapi.client.sheets.spreadsheets.values.update({
    spreadsheetId,
    range,
    valueInputOption: 'RAW',
    resource: {
      values
    }
  });
};

/**
 * Performs a batch update for multiple cards.
 * Used for syncing the offline backlog.
 */
export const batchUpdateCards = async (spreadsheetId: string, updates: PendingCardUpdate[]): Promise<void> => {
  if (!window.gapi?.client?.sheets) {
    throw new Error("Google Sheets API not loaded");
  }

  // 1. Fetch current sheet state to map IDs to Rows
  const response = await window.gapi.client.sheets.spreadsheets.values.get({
    spreadsheetId,
    range: 'Sheet1!A2:G',
  });
  const rows = response.result.values || [];

  const data: any[] = [];

  // 2. Build update payload
  for (const update of updates) {
    // Attempt ID match
    let rowIndex = rows.findIndex((row: any[]) => row[6] === update.id);
    
    // Note: In batch mode, we can't easily do the content fallback because we don't have front/back in PendingCardUpdate.
    // However, if the card was in the backlog, it likely has an ID already known to the app. 
    // If it's a new ID that never hit the sheet, batch sync might fail for that specific card if rows moved.
    // Given the ID is generated on Load, this is mostly safe unless user deleted the row.

    if (rowIndex !== -1) {
       const rowNumber = rowIndex + 2;
       data.push({
         range: `Sheet1!E${rowNumber}:G${rowNumber}`,
         values: [[update.lastSeen, update.currentStudyInterval, update.id]]
       });
    }
  }

  if (data.length === 0) return;

  await window.gapi.client.sheets.spreadsheets.values.batchUpdate({
    spreadsheetId,
    resource: {
      valueInputOption: 'RAW',
      data: data
    }
  });
};
